# 보안 질문

## 클라이언트 및 서버 연결을 어떻게 암호화 할까요?

버전 4.0 전에는 자체 설계 프로토콜로만 동기화 했습니다. 모든 Seafile 데스크톱 클라이언트는 유일 개인 키가 있습니다. 클라이언트 및 서버를 서로 연결하면 공용키를 교환하고 세션키를 서로 배분합니다. 세션 키는 PDKDF2 알고리즘에 따른 암호화 보안 임의 숫자값입니다. 그리고 RSA 암호화를 통해 클라이언트 및 서버간 교환합니다. 세션키는 AES-256/CBC 알고리즘으로 데이터 전송을 암호화할 때 사용합니다.

4.0 버전에서 Seafile은 좀 더 표준에 가까운 방식인 HTTP(S) 프로토콜 동기화를 지원합니다.

4.1 버전에서 Seafile은 기본적으로 HTTP(S) 동기화 프로토콜을 사용합니다.

## 암호화 라이브러리

Seafile에서는 개인 정보를 보호할 목적으로 암호화 라이브러리 기능을 제공합니다. 파일 암호화/복호화 과정은 파일 동기화 목적으로 데스크톱 클라이언트를 사용할 때 클라이언트 측에서 처리합니다. 암호화한 라이브러리의 암호는 서버에 저장하지 않습니다. **서버의 시스템 관리자 조차도 파일 내용을 볼 수 없습니다. 오직 [암호화 하지 않은](https://github.com/haiwen/seafile/issues/350) 메타데이터를 볼 수 있을 뿐입니다**. 메타데이터에는 디렉터리 및 파일 전체 목록, 모든 파일 크기, 파일을 바꾼 기록, 언제, 어떤 바이트 영역을 바꾸었는지에 대한 정보가 들어있습니다.

위험: 클라이언트측 암호화는 웹 브라우저 및 데스크톱 클라이언트의 클라우드 파일 브라우저에서는 동작하지 않습니다.  암호화 라이브러리를 웹 브라우저로 탐색하는 경우와 클라우드 파일 브라우저로 탐색하는 경우, 암호를 입력해야합니다. 그리고 서버에서는 라이브러리용 "파일 키"를 해독(하단 설명 참고)할 때 암호를 사용하며, 한 시간 단위로 캐시 메모리에 저장해둡니다. 일반 텍스트 암호는 서버에 저장하거나 별도의 캐시에 저장하지 않습니다.

업데이트: 클라이언트 측면 암호화는 iOS 클라이언트 2.1.6부터 동작합니다. 안드로이드 클라이언트는 클라이언트측 암호화를 아직 지원하지 않습니다. 


## 암호화 라이브러리는 어떻게 동작할까요?

암호화 라이브러리를 만들 때, 암호를 입력합니다. 헤당 라이브러리의 모든 데이터는 서버에 업로드하기 전 사용자가 입력한 암호로 암호화합니다.

암호화 과정은 다음과 같습니다:

1. 32 바이트 길이 암호화 세기 임의 숫자를 생성합니다. 이 값을 파일 암호화 키("파일 키")로 사용합니다.
2. 파일 키는 사용자가 제공한 암호로 암호화합니다. 우선 PBKDF2 알고리즘(SHA256의 1000번 순차 반복)을 우선 사용하여 암호에서 key/iv 쌍을 가져온 후, AES 256/CBC로 파일 키를 암호화합니다. 결과는 "암호화한 파일 키" 입니다. 이 암호화 파일 키는 서버에 저장합니다. 데이터에 접근하려 하면 암호화 파일 키를 해독하여 파일 키를 가져올 수 있습니다.
3. 모든 파일 데이터는 AES 256/CBC로 파일 키를 사용하여 암호화합니다. PBKDF2 알고리즘(SHA256의 1000번 순차 반복)으로 파일 키에서 key/iv 쌍을 가져옵니다. 암호화 처리가 끝나면 데이터를 서버에 업로드합니다.

위 암호화 과정은 데스크톱 및 모바일 클라이언트에서 진행할 수 있습니다. Seahub 브라우저 클라이언트에서는 서버에서 일어나는 제각기 다른 암호화 과정을 활용합니다. 여러분이 설정한 암호를 서버로 전송하기 때문입니다.

데스크톱에서 암호화한 라이브러리를 동기화하면 클라이언트에서 암호 확인이 필요합니다. 라이브러리를 만들면 암호 및 라이브러리 ID에서 가져온 "매직 토큰"을 가져옵니다. 이 토큰은 서버 측의 라이브러리에 저장합니다. 클라이언트는 이 토큰으로 라이브러리 동기화 전 암호가 일치한 지 확인할 때 이 토큰을 활용합니다. 매직 토큰은 SHA256 해시를 1천번 반복하는 PBKDF2 알고리즘으로 만듭니다.

최대한의 보안을 목적으로, 원문 텍스트 암호는 클라이언트에도 저장하지 않습니다. 클라이언트에만 암호화 데이터를 해독할 때 사용하는 "파일 키"에서 가져온 key/iv 쌍을 저장합니다. 따라서 암호를 잊었다면, 복원하거나 서버의 데이터에 접근할 수 없습니다.

## 왜 파일 서버에서 공유하지 않은 개인 파일의 컨텐트 URL을 모두가 알도록 전달할까요?

파일 다운로드 링크를 누르면, 파일 서버에서 파일에 접근할 수 있게 사용자에게 임의 URL을 만들어줍니다. 이 URL은 한번만 접근할 수 있습니다. 그 다음에는 해당 URL의 모든 접근을 막습니다. 따라서 누군가가 URL을 알아냈다 치더라도 해당 주소로 더 이상 접근할 수 없습니다.

## Seafile은 사용자 로그인 암호를 어떻게 저장할까요?

사용자 로그인 암호는 해시 모양으로만 저장합니다. 참고로 사용자 로그인 암호는 암호화 라이브러리에서 사용한 암호랑은 다릅니다. 데이터베이스에서의 형식은 다음과 같습니다

```
PBKDF2SHA256$iterations$salt$hash
```

레코드는 $ 기호를 기준으로 네 부분으로 나눕니다.

- 처음 부분은 사용할 해시 알고리즘입니다. 현재 PBKDF2 및 SHA256을 사용합니다. 필요한 경우 더 강력한 알고리즘으로 바꿀 수 있습니다.
- 두번째 부분은 해시 알고리즘 반복 횟수입니다
- 세번째 부분은 해시를 만들 때 사용하는 임의 솔트 값입니다
- 네번째 부분은 암호로 만든 최종 해시입니다

해시를 처리하는 방법은,

- 우선 32바이트 길이 암호화 강도 임의 숫자를 만들고 이걸 솔트로 활용합니다.
- `PBKDF2(password, salt, iterations)`로 해시를 계산합니다. 반복 횟수는 현재 1만번입니다.

