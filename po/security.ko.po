# Korean translation for the seafile-docs package.
# This file is distributed under the same license as the seafile-docs package.
# Seong-ho Cho <darkcircle.0426@gmail.com>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: seafile-docs\n"
"Report-Msgid-Bugs-To: https://github.com/haiwen/seafile-docs/issues\n"
"POT-Creation-Date: 2016-04-19 21:46:37+0900\n"
"PO-Revision-Date: 2016-04-26 15:05+0900\n"
"Last-Translator: Seong-ho Cho <darkcircle.0426@gmail.com>\n"
"Language-Team: Korean <darkcircle.0426@gmail.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.7\n"

# header
#: security/README.md:1
msgid "# Security and auditing"
msgstr "# 보안 및 감사"

# header
#: security/README.md:3
msgid "## Security features "
msgstr "## 보안 기능 "

# unordered list
#: security/README.md:5
msgid "* [Security features](security_features.md)"
msgstr "* [보안 기능](security_features.md)"

# header
#: security/README.md:7
msgid "## Access log and auditing"
msgstr "## 접근 기록 및 감사"

# unordered list
#: security/README.md:9
msgid "* [Access log and auditing](auditing.md)"
msgstr "* [접근 기록 및 감사](auditing.md)"

# header
#: security/auditing.md:1
msgid "# Access log and auditing"
msgstr "# 접근 기록 및 감사"

#: security/auditing.md:3
msgid ""
"In pro edition, Seafile offers four auditing logs in system admin panel:"
msgstr ""
"Seafile 전문가판에서는 시스템 관리자 창에서 네가지 감사 로그를 제공합니다:"

# unordered list
#: security/auditing.md:5
msgid "* Login log"
msgstr "* 로그인 기록"

# unordered list
#: security/auditing.md:6
msgid "* File access log"
msgstr "* 파일 접근 기록"

# unordered list
#: security/auditing.md:7
msgid "* File update log"
msgstr "* 파일 업데이트 기록"

# unordered list
#: security/auditing.md:8
msgid "* Permission change log"
msgstr "* 권한 변경 기록"

#: security/auditing.md:10
msgid "![Seafile Auditing Log](../images/admin-audit-log.png)"
msgstr "![Seafile 감사 로그](../images/admin-audit-log.png)"

#: security/auditing.md:12
msgid ""
"The logging feature is turned off by default. See [config options for pro "
"edition](../deploy_pro/configurable_options.md) for how to turn it on."
msgstr ""
"기록 기능은 기본적으로 꺼져있습니다. 기능을 켜는 방법은 [전문가판 설정 항목]"
"(../deploy_pro/configurable_options.md) 편을 참고하십시오."

# header
#: security/security_features.md:1
msgid "# Security Questions"
msgstr "# 보안 질문"

# header
#: security/security_features.md:3
msgid "## How is the connection between client and server encrypted?"
msgstr "## 클라이언트 및 서버 연결을 어떻게 암호화 할까요?"

#: security/security_features.md:5
msgid ""
"Before version 4.0, Seafile only supports syncing via a self-designed "
"protocol. Every seafile desktop client has a unique private key. When a "
"client and a server connect, they will exchange public key and negotiate a "
"session key. The session key is derived from cryptographically secure random "
"number with PDKDF2 algorithm. And it's exchanged between the client and the "
"server with RSA encryption. This session key will be used to encrypt the "
"data transfer with AES-256/CBC algorithm. "
msgstr ""
"버전 4.0 전에는 자체 설계 프로토콜로만 동기화 했습니다. 모든 Seafile 데스크"
"톱 클라이언트는 유일 개인 키가 있습니다. 클라이언트 및 서버를 서로 연결하면 "
"공용키를 교환하고 세션키를 서로 배분합니다. 세션 키는 PDKDF2 알고리즘에 따른 "
"암호화 보안 임의 숫자값입니다. 그리고 RSA 암호화를 통해 클라이언트 및 서버간 "
"교환합니다. 세션키는 AES-256/CBC 알고리즘으로 데이터 전송을 암호화할 때 사용"
"합니다."

#: security/security_features.md:7
msgid ""
"From version 4.0, Seafile supports syncing via HTTP(S) protocol, which is a "
"more standard approach."
msgstr ""
"4.0 버전에서 Seafile은 좀 더 표준에 가까운 방식인 HTTP(S) 프로토콜 동기화를 "
"지원합니다."

#: security/security_features.md:9
msgid "From version 4.1, Seafile uses HTTP(S) syncing protocol by default."
msgstr ""
"4.1 버전에서 Seafile은 기본적으로 HTTP(S) 동기화 프로토콜을 사용합니다."

# header
#: security/security_features.md:11
msgid "## Encrypted Library"
msgstr "## 암호화 라이브러리"

#: security/security_features.md:13
msgid ""
"Seafile provides a feature called encrypted library to protect your privacy. "
"The file encryption/decryption is performed in the client-side when using "
"the desktop client for file syncing. The password of an encrypted library is "
"not stored in the server. **Even the system admin of the server can't view "
"the file contents - they can however view the metadata [which are currently "
"not encrypted](https://github.com/haiwen/seafile/issues/350).** The metadata "
"includes: the complete list of directory and file names, every file size, "
"the history of who changed each file, when, and what byte ranges were "
"altered."
msgstr ""
"Seafile에서는 개인 정보를 보호할 목적으로 암호화 라이브러리 기능을 제공합니"
"다. 파일 암호화/복호화 과정은 파일 동기화 목적으로 데스크톱 클라이언트를 사용"
"할 때 클라이언트 측에서 처리합니다. 암호화한 라이브러리의 암호는 서버에 저장"
"하지 않습니다. **서버의 시스템 관리자 조차도 파일 내용을 볼 수 없습니다. 오"
"직 [암호화 하지 않은](https://github.com/haiwen/seafile/issues/350) 메타데이"
"터를 볼 수 있을 뿐입니다**. 메타데이터에는 디렉터리 및 파일 전체 목록, 모든 "
"파일 크기, 파일을 바꾼 기록, 언제, 어떤 바이트 영역을 바꾸었는지에 대한 정보"
"가 들어있습니다."

#: security/security_features.md:15
msgid ""
"CAUTION: The client side encryption is not work currently for web browser "
"and the cloud file browser of the desktop client. When you browsing "
"encrypted libraries via the web browser and the cloud file browser, you will "
"need to input the password. And the server will use the password to decrypt "
"the \"file key\" for the library (see description below) and cache it in "
"memory for 1 hour. The plain text password is never stored or cached on the "
"server."
msgstr ""
"위험: 클라이언트측 암호화는 웹 브라우저 및 데스크톱 클라이언트의 클라우드 파"
"일 브라우저에서는 동작하지 않습니다.  암호화 라이브러리를 웹 브라우저로 탐색"
"하는 경우와 클라우드 파일 브라우저로 탐색하는 경우, 암호를 입력해야합니다. 그"
"리고 서버에서는 라이브러리용 \"파일 키\"를 해독(하단 설명 참고)할 때 암호를 "
"사용하며, 한 시간 단위로 캐시 메모리에 저장해둡니다. 일반 텍스트 암호는 서버"
"에 저장하거나 별도의 캐시에 저장하지 않습니다."

#: security/security_features.md:17
msgid ""
"Update: The client side encryption works on iOS client since version 2.1.6. "
"The Android client doesn't support client side encryption yet. "
msgstr ""
"업데이트: 클라이언트 측면 암호화는 iOS 클라이언트 2.1.6부터 동작합니다. 안드"
"로이드 클라이언트는 클라이언트측 암호화를 아직 지원하지 않습니다. "

# header
#: security/security_features.md:20
msgid "## How does an encrypted library work?"
msgstr "## 암호화 라이브러리는 어떻게 동작할까요?"

#: security/security_features.md:22
msgid ""
"When you create an encrypted library, you'll provide a password for it. All "
"the data in that library will be encrypted with the password before "
"uploading to the server."
msgstr ""
"암호화 라이브러리를 만들 때, 암호를 입력합니다. 헤당 라이브러리의 모든 데이터"
"는 서버에 업로드하기 전 사용자가 입력한 암호로 암호화합니다."

#: security/security_features.md:24
msgid "The encryption procedure is:"
msgstr "암호화 과정은 다음과 같습니다:"

# ordered list
#: security/security_features.md:26
msgid ""
"1. Generate a 32-byte long cryptographically strong random number. This will "
"be used as the file encryption key (\"file key\")."
msgstr ""
"1. 32 바이트 길이 암호화 세기 임의 숫자를 생성합니다. 이 값을 파일 암호화 키"
"(\"파일 키\")로 사용합니다."

# ordered list
#: security/security_features.md:27
msgid ""
"2. Encrypt the file key with the user provided password. We first use PBKDF2 "
"algorithm (1000 iteratioins of SHA256) to derive a key/iv pair from the "
"password, then use AES 256/CBC to encrypt the file key. The result is called "
"the \"encrypted file key\". This encrypted file key will be sent to and "
"stored on the server. When you need to access the data, you can decrypt the "
"file key from the encrypted file key."
msgstr ""
"2. 파일 키는 사용자가 제공한 암호로 암호화합니다. 우선 PBKDF2 알고리즘(SHA256"
"의 1000번 순차 반복)을 우선 사용하여 암호에서 key/iv 쌍을 가져온 후, AES 256/"
"CBC로 파일 키를 암호화합니다. 결과는 \"암호화한 파일 키\" 입니다. 이 암호화 "
"파일 키는 서버에 저장합니다. 데이터에 접근하려 하면 암호화 파일 키를 해독하"
"여 파일 키를 가져올 수 있습니다."

# ordered list
#: security/security_features.md:28
msgid ""
"3. All file data is encrypted by the file key with AES 256/CBC. We use "
"PBKDF2 algorithm (1000 iterations of SHA256) to derive key/iv pair from the "
"file key. After encryption, the data is uploaded to the server."
msgstr ""
"3. 모든 파일 데이터는 AES 256/CBC로 파일 키를 사용하여 암호화합니다. PBKDF2 "
"알고리즘(SHA256의 1000번 순차 반복)으로 파일 키에서 key/iv 쌍을 가져옵니다. "
"암호화 처리가 끝나면 데이터를 서버에 업로드합니다."

#: security/security_features.md:30
msgid ""
"The above encryption procedure can be executed on the desktop and the mobile "
"client. The Seahub browser client uses a different encryption procedure that "
"happens at the server. Because of this your password will be transferred to "
"the server."
msgstr ""
"위 암호화 과정은 데스크톱 및 모바일 클라이언트에서 진행할 수 있습니다. "
"Seahub 브라우저 클라이언트에서는 서버에서 일어나는 제각기 다른 암호화 과정을 "
"활용합니다. 여러분이 설정한 암호를 서버로 전송하기 때문입니다."

#: security/security_features.md:32
msgid ""
"When you sync an encrypted library to the desktop, the client needs to "
"verify your password. When you create the library, a \"magic token\" is "
"derived from the password and library id. This token is stored with the "
"library on the server side. The client use this token to check whether your "
"password is correct before you sync the library. The magic token is "
"generated by PBKDF2 algorithm with 1000 iterations of SHA256 hash."
msgstr ""
"데스크톱에서 암호화한 라이브러리를 동기화하면 클라이언트에서 암호 확인이 필요"
"합니다. 라이브러리를 만들면 암호 및 라이브러리 ID에서 가져온 \"매직 토큰\"을 "
"가져옵니다. 이 토큰은 서버 측의 라이브러리에 저장합니다. 클라이언트는 이 토큰"
"으로 라이브러리 동기화 전 암호가 일치한 지 확인할 때 이 토큰을 활용합니다. 매"
"직 토큰은 SHA256 해시를 1천번 반복하는 PBKDF2 알고리즘으로 만듭니다."

#: security/security_features.md:34
msgid ""
"For maximum security, the plain-text password won't be saved on the client "
"side too. The client only saves the key/iv pair derived from the \"file key"
"\", which is used to decrypt the data. So if you forget the password, you "
"won't be able to recover it or access your data on the server."
msgstr ""
"최대한의 보안을 목적으로, 원문 텍스트 암호는 클라이언트에도 저장하지 않습니"
"다. 클라이언트에만 암호화 데이터를 해독할 때 사용하는 \"파일 키\"에서 가져온 "
"key/iv 쌍을 저장합니다. 따라서 암호를 잊었다면, 복원하거나 서버의 데이터에 접"
"근할 수 없습니다."

# header
#: security/security_features.md:36
msgid ""
"## Why fileserver delivers every content to everybody knowing the content "
"URL of an unshared private file?"
msgstr ""
"## 왜 파일 서버에서 공유하지 않은 개인 파일의 컨텐트 URL을 모두가 알도록 전달"
"할까요?"

#: security/security_features.md:38
msgid ""
"When a file download link is clicked, a random URL is generated for user to "
"access the file from fileserver. This url can only be access for once. After "
"that, all access will be denied to the url. So even someone else happens to "
"know about the url, he/she can't access it any more."
msgstr ""
"파일 다운로드 링크를 누르면, 파일 서버에서 파일에 접근할 수 있게 사용자에게 "
"임의 URL을 만들어줍니다. 이 URL은 한번만 접근할 수 있습니다. 그 다음에는 해"
"당 URL의 모든 접근을 막습니다. 따라서 누군가가 URL을 알아냈다 치더라도 해당 "
"주소로 더 이상 접근할 수 없습니다."

# header
#: security/security_features.md:40
msgid "## How does Seafile store user login password?"
msgstr "## Seafile은 사용자 로그인 암호를 어떻게 저장할까요?"

#: security/security_features.md:42
msgid ""
"User login passwords are stored in hash form only. Note that user login "
"password is different from the passwords used in encrypted libraries. In the "
"database, it's format is"
msgstr ""
"사용자 로그인 암호는 해시 모양으로만 저장합니다. 참고로 사용자 로그인 암호는 "
"암호화 라이브러리에서 사용한 암호랑은 다릅니다. 데이터베이스에서의 형식은 다"
"음과 같습니다"

# code block
#: security/security_features.md:44
msgid ""
"```\n"
"PBKDF2SHA256$iterations$salt$hash\n"
"```"
msgstr ""
"```\n"
"PBKDF2SHA256$iterations$salt$hash\n"
"```"

#: security/security_features.md:48
msgid "The record is divided into 4 parts by the $ sign."
msgstr "레코드는 $ 기호를 기준으로 네 부분으로 나눕니다."

# unordered list
#: security/security_features.md:50
msgid ""
"- The first part is the hash algorithm used. Currently we use PBKDF2 with "
"SHA256. It can be changed to even stronger algorithm if needed."
msgstr ""
"- 처음 부분은 사용할 해시 알고리즘입니다. 현재 PBKDF2 및 SHA256을 사용합니"
"다. 필요한 경우 더 강력한 알고리즘으로 바꿀 수 있습니다."

# unordered list
#: security/security_features.md:51
msgid "- The second part is the number of iterations of the hash algorithm"
msgstr "- 두번째 부분은 해시 알고리즘 반복 횟수입니다"

# unordered list
#: security/security_features.md:52
msgid "- The third part is the random salt used for generating the hash"
msgstr "- 세번째 부분은 해시를 만들 때 사용하는 임의 솔트 값입니다"

# unordered list
#: security/security_features.md:53
msgid "- The fourth part is the final hash generated from the password"
msgstr "- 네번째 부분은 암호로 만든 최종 해시입니다"

#: security/security_features.md:55
msgid "The calculate the hash,"
msgstr "해시를 처리하는 방법은,"

# unordered list
#: security/security_features.md:57
msgid ""
"- First, generate a 32-byte long cryptographically strong random number, use "
"it as the salt."
msgstr ""
"- 우선 32바이트 길이 암호화 강도 임의 숫자를 만들고 이걸 솔트로 활용합니다."

# unordered list
#: security/security_features.md:58
msgid ""
"- Calculate the hash with `PBKDF2(password, salt, iterations)`. The number "
"of iterations is currently 10000."
msgstr ""
"- `PBKDF2(password, salt, iterations)`로 해시를 계산합니다. 반복 횟수는 현재 "
"1만번입니다."
